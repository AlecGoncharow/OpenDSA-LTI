{"connections": {"con-49": {"to": "isa", "from": "Prim's algorithm"}, "con-48": {"to": "Prim's algorithm", "from": "algorithms"}, "con-43": {"to": "uses", "from": "Kruskal's algorithm"}, "con-42": {"to": "unweighted graph", "from": "types"}, "con-41": {"to": "types", "from": "graph"}, "con-40": {"to": "weighted graph", "from": "types"}, "con-47": {"to": "algorithms", "from": "minimal-cost spanning tree"}, "con-46": {"to": "Kruskal's algorithm", "from": "algorithms"}, "con-45": {"to": "algorithms", "from": "minimal-cost spanning tree"}, "con-44": {"to": "UNION/FIND", "from": "uses"}, "con-36": {"to": "labeled graph", "from": "types"}, "con-29": {"to": "types", "from": "graph"}, "con-28": {"to": "dense", "from": "types"}, "con-37": {"to": "types", "from": "graph"}, "con-25": {"to": "problems", "from": "graph"}, "con-24": {"to": "topological sort", "from": "problems"}, "con-27": {"to": "types", "from": "graph"}, "con-26": {"to": "shortest paths", "from": "problems"}, "con-21": {"to": "problems", "from": "graph"}, "con-20": {"to": "minimal-cost spanning tree", "from": "problems"}, "con-23": {"to": "problems", "from": "graph"}, "con-22": {"to": "traversal", "from": "problems"}, "con-35": {"to": "types", "from": "graph"}, "con-32": {"to": "directed graph", "from": "types"}, "con-33": {"to": "types", "from": "graph"}, "con-30": {"to": "sparse graph", "from": "types"}, "con-31": {"to": "types", "from": "graph"}, "con-50": {"to": "greedy algorithm", "from": "isa"}, "con-18": {"to": "adjacency list", "from": "implementedby"}, "con-19": {"to": "problems", "from": "graph"}, "con-38": {"to": "undirected graph", "from": "types"}, "con-39": {"to": "types", "from": "graph"}, "con-10": {"to": "digraph", "from": "abbreviation"}, "con-11": {"to": "contains", "from": "graph"}, "con-12": {"to": "edges <edge>", "from": "contains"}, "con-13": {"to": "contains", "from": "graph"}, "con-14": {"to": "vertices <vertex>", "from": "contains"}, "con-15": {"to": "implementedby", "from": "graph"}, "con-16": {"to": "adjacency matrix", "from": "implementedby"}, "con-17": {"to": "implementedby", "from": "graph"}, "con-34": {"to": "acyclic graph", "from": "types"}, "con-8": {"to": "directed acyclic graph", "from": "types"}, "con-9": {"to": "abbreviation", "from": "directed graph"}, "con-6": {"to": "DAG", "from": "abbreviation"}, "con-7": {"to": "types", "from": "directed graph"}, "con-4": {"to": "algorithm", "from": "typeof"}, "con-5": {"to": "abbreviation", "from": "directed acyclic graph"}, "con-2": {"to": "directed acyclic graph", "from": "types"}, "con-3": {"to": "typeof", "from": "bubble sort"}, "con-1": {"to": "types", "from": "acyclic graph"}}, "linking_phrase": {"implementedby": " implemented by\r\n", "contains": " contains\r\n", "problems": " problems\r\n", "abbreviation": " abbreviation\r\n", "uses": " uses", "typeof": " type of", "algorithms": " algorithms\r\n", "isa": " is a", "types": " types\r\n"}, "concepts": {"shortest paths": "", "Prim's algorithm": "<dd>A <a class=\"reference internal\" href=\"#term-greedy-algorithm\"><span class=\"xref std std-term\">greedy algorithm</span></a> for computing the <a class=\"reference internal\" href=\"#term-mcst\"><span class=\"xref std std-term\">MCST</span></a> of a\n<a class=\"reference internal\" href=\"#term-graph\"><span class=\"xref std std-term\">graph</span></a>.\nIt is nearly identical to <a class=\"reference internal\" href=\"#term-dijkstra-s-algorithm\"><span class=\"xref std std-term\">Dijkstra's algorithm</span></a> for\nsolving the <a class=\"reference internal\" href=\"#term-single-source-shortest-paths-problem\"><span class=\"xref std std-term\">single-source shortest paths problem</span></a>,\nwith the only difference being the calculation done to update\nthe best-known distance.</dd>", "edges <edge>": "", "digraph": "<dd>Abbreviation for <a class=\"reference internal\" href=\"#term-directed-graph\"><span class=\"xref std std-term\">directed graph</span></a>.</dd>", "directed graph": "<dd>A <a class=\"reference internal\" href=\"#term-graph\"><span class=\"xref std std-term\">graph</span></a> whose <a class=\"reference internal\" href=\"#term-edge\"><span class=\"xref std std-term\">edges</span></a> each are directed\nfrom one of its defining <a class=\"reference internal\" href=\"#term-vertex\"><span class=\"xref std std-term\">vertices</span></a> to the\nother.</dd>", "greedy algorithm": "<dd>An algorithm that makes locally optimal choices at each step.</dd>", "DAG": "<dd>Abbreviation for <a class=\"reference internal\" href=\"#term-directed-acyclic-graph\"><span class=\"xref std std-term\">directed acyclic graph</span></a>.</dd>", "dense": "", "bubble sort": "<dd>A simple sort that requires <span class=\"math\">\\(Theta(n^2)\\)</span> time in best,\naverage, and worst cases.\nEven an optimized version will normally run slower than\n<a class=\"reference internal\" href=\"#term-insertion-sort\"><span class=\"xref std std-term\">insertion sort</span></a>, so it has little to recommend it.</dd>", "unweighted graph": "", "graph": "<dd>A <a class=\"reference internal\" href=\"#term-graph\"><span class=\"xref std std-term\">graph</span></a> <span class=\"math\">\\(\\mathbf{G} = (\\mathbf{V}, \\mathbf{E})\\)</span>\nconsists of a set of <a class=\"reference internal\" href=\"#term-vertex\"><span class=\"xref std std-term\">vertices</span></a>\n<span class=\"math\">\\(\\mathbf{V}\\)</span> and a set of <a class=\"reference internal\" href=\"#term-edge\"><span class=\"xref std std-term\">edges</span></a>\n<span class=\"math\">\\(\\mathbf{E}\\)</span>, such that each edge in <span class=\"math\">\\(\\mathbf{E}\\)</span> is\na connection between a pair of vertices in <span class=\"math\">\\(\\mathbf{V}\\)</span>.</dd>", "Kruskal's algorithm": "<dd>An algorithm for computing the <a class=\"reference internal\" href=\"#term-mcst\"><span class=\"xref std std-term\">MCST</span></a> of a\n<a class=\"reference internal\" href=\"#term-graph\"><span class=\"xref std std-term\">graph</span></a>.\nDuring processing, it makes use of the <a class=\"reference internal\" href=\"#term-union-find\"><span class=\"xref std std-term\">UNION/FIND</span></a>\nprocess to efficiently determine of two vertices are within the\nsame <a class=\"reference internal\" href=\"#term-subgraph\"><span class=\"xref std std-term\">subgraph</span></a>.</dd>", "adjacency list": "<dd>An implementation for a <a class=\"reference internal\" href=\"#term-graph\"><span class=\"xref std std-term\">graph</span></a> that uses an (array-based)\n<a class=\"reference internal\" href=\"#term-list\"><span class=\"xref std std-term\">list</span></a> to represent the <a class=\"reference internal\" href=\"#term-vertex\"><span class=\"xref std std-term\">vertices</span></a> of the\ngraph, and each vertex is in turn represented by a\n(linked) list of the vertices that are\n<a class=\"reference internal\" href=\"#term-neighbor\"><span class=\"xref std std-term\">neighbors</span></a>.</dd>", "labeled graph": "<dd>A <a class=\"reference internal\" href=\"#term-graph\"><span class=\"xref std std-term\">graph</span></a> with labels associated with the\n<a class=\"reference internal\" href=\"#term-node\"><span class=\"xref std std-term\">nodes</span></a>.</dd>", "minimal-cost spanning tree": "<dd>Abbreviated as MCST, or sometimes as MST.\nDerived from a <a class=\"reference internal\" href=\"#term-weighted-graph\"><span class=\"xref std std-term\">weighted graph</span></a>, the MCST is the\n<a class=\"reference internal\" href=\"#term-subset\"><span class=\"xref std std-term\">subset</span></a> of the graph's <a class=\"reference internal\" href=\"#term-edge\"><span class=\"xref std std-term\">edges</span></a> that\nmaintains the connectivitiy of the graph while having lowest\ntotal cost (as defined by the sum of the\n<a class=\"reference internal\" href=\"#term-weight\"><span class=\"xref std std-term\">weights</span></a> of the edges in the MCST).\nThe result is referred to as a <a class=\"reference internal\" href=\"#term-504\"><span class=\"xref std std-term\">tree</span></a> because it would\nnever have a <a class=\"reference internal\" href=\"#term-cycle\"><span class=\"xref std std-term\">cycle</span></a> (since an edge could be removed from\nthe cycle and still preserve connectivity).\nTwo algorithms to solve this problem are\n<a class=\"reference internal\" href=\"#term-prim-s-algorithm\"><span class=\"xref std std-term\">Prim's algorithm</span></a> and <a class=\"reference internal\" href=\"#term-kruskal-s-algorithm\"><span class=\"xref std std-term\">Kruskal's algorithm</span></a>.</dd>", "traversal": "<dd>Any process for visiting all of the objects in a collection\n(such as a <a class=\"reference internal\" href=\"#term-504\"><span class=\"xref std std-term\">tree</span></a> or <a class=\"reference internal\" href=\"#term-graph\"><span class=\"xref std std-term\">graph</span></a>) in some order.</dd>", "topological sort": "<dd>The process of laying out the <a class=\"reference internal\" href=\"#term-vertex\"><span class=\"xref std std-term\">vertices</span></a> of a\n<a class=\"reference internal\" href=\"#term-dag\"><span class=\"xref std std-term\">DAG</span></a> in a <a class=\"reference internal\" href=\"#term-linear-order\"><span class=\"xref std std-term\">linear order</span></a> such that no vertex\n<span class=\"math\">\\(A\\)</span> in the order is preceded by a vertex that can be\nreached by a (directed) <a class=\"reference internal\" href=\"#term-path\"><span class=\"xref std std-term\">path</span></a> from <span class=\"math\">\\(A\\)</span>.\nUsually the (directed) edges in the graph define a\nprerequisite system, and the goal of the topological sort is\nto list the vertices in an order such that no prerequisites are\nviolated.</dd>", "adjacency matrix": "<dd>An implementation for a <a class=\"reference internal\" href=\"#term-graph\"><span class=\"xref std std-term\">graph</span></a> that uses a 2-dimensional\narray where each row and each column corresponds to a\n<a class=\"reference internal\" href=\"#term-vertex\"><span class=\"xref std std-term\">vertex</span></a> in the <a class=\"reference internal\" href=\"#term-graph\"><span class=\"xref std std-term\">graph</span></a>. A given row and column in\nthe matrix corresponds to an edge from the <a class=\"reference internal\" href=\"#term-vertex\"><span class=\"xref std std-term\">vertex</span></a>\ncorresponding to the row to the vertex corresponding to the\ncolumn.</dd>", "acyclic graph": "<dd>In <a class=\"reference internal\" href=\"#term-graph\"><span class=\"xref std std-term\">graph</span></a> terminology, a graph that contains no\n<a class=\"reference internal\" href=\"#term-cycle\"><span class=\"xref std std-term\">cycles</span></a>.</dd>", "weighted graph": "<dd>A <a class=\"reference internal\" href=\"#term-graph\"><span class=\"xref std std-term\">graph</span></a> whose <a class=\"reference internal\" href=\"#term-edge\"><span class=\"xref std std-term\">edges</span></a> each have an\nassociated <a class=\"reference internal\" href=\"#term-weight\"><span class=\"xref std std-term\">weight</span></a> or cost.</dd>", "algorithm": "<dd>A method or a process followed to solve a <a class=\"reference internal\" href=\"#term-problem\"><span class=\"xref std std-term\">problem</span></a>.</dd>", "UNION/FIND": "<dd>A process for mainining a collection of disjoint sets.\nThe <a class=\"reference internal\" href=\"#term-find\"><span class=\"xref std std-term\">FIND</span></a> operation determines which disjoint set a given\nobject resides in, and the <a class=\"reference internal\" href=\"#term-union\"><span class=\"xref std std-term\">UNION</span></a> operation combines two\ndisjoint sets when it is determined that they are members of the\nsame <a class=\"reference internal\" href=\"#term-equivalence-class\"><span class=\"xref std std-term\">equivalence class</span></a> under some\n<a class=\"reference internal\" href=\"#term-equivalence-relation\"><span class=\"xref std std-term\">equivalence relation</span></a>.</dd>", "directed acyclic graph": "<dd>A <a class=\"reference internal\" href=\"#term-graph\"><span class=\"xref std std-term\">graph</span></a> with no cycles.\nAbbreviated as <a class=\"reference internal\" href=\"#term-dag\"><span class=\"xref std std-term\">DAG</span></a>.\nNote that a DAG is not necessarily a <a class=\"reference internal\" href=\"#term-504\"><span class=\"xref std std-term\">tree</span></a> since a given\n<a class=\"reference internal\" href=\"#term-node\"><span class=\"xref std std-term\">node</span></a> might have multiple <a class=\"reference internal\" href=\"#term-parent\"><span class=\"xref std std-term\">parents</span></a>.</dd>", "sparse graph": "<dd>A <a class=\"reference internal\" href=\"#term-graph\"><span class=\"xref std std-term\">graph</span></a> where the actual number of <a class=\"reference internal\" href=\"#term-edge\"><span class=\"xref std std-term\">edges</span></a>\nis much less than the possible number of edges.\nGenerally, this is interpreted to mean that the <a class=\"reference internal\" href=\"#term-degree\"><span class=\"xref std std-term\">degree</span></a>\nfor any <a class=\"reference internal\" href=\"#term-vertex\"><span class=\"xref std std-term\">vertex</span></a> in the graph is relatively low.</dd>", "undirected graph": "<dd>A <a class=\"reference internal\" href=\"#term-graph\"><span class=\"xref std std-term\">graph</span></a> whose <a class=\"reference internal\" href=\"#term-edge\"><span class=\"xref std std-term\">edges</span></a> do not have a direction.</dd>", "vertices <vertex>": ""}}